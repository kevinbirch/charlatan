// generated by "charlatan -dir=testdata/qualifier -output=testdata/qualifier/qualifier.go Qualifier".  DO NOT EDIT.

package main

import "reflect"
import "fmt"

// QualifierQualifyInvocation represents a single call of FakeQualifier.Qualify
type QualifierQualifyInvocation struct {
	Parameters struct {
		Ident1 fmt.Scanner
	}
	Results struct {
		Ident2 fmt.Scanner
	}
}

// NewQualifierQualifyInvocation creates a new instance of QualifierQualifyInvocation
func NewQualifierQualifyInvocation(ident1 fmt.Scanner, ident2 fmt.Scanner) *QualifierQualifyInvocation {
	invocation := new(QualifierQualifyInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// QualifierNamedQualifyInvocation represents a single call of FakeQualifier.NamedQualify
type QualifierNamedQualifyInvocation struct {
	Parameters struct {
		A fmt.Scanner
		B fmt.Scanner
		C fmt.Scanner
	}
	Results struct {
		D fmt.Scanner
	}
}

// NewQualifierNamedQualifyInvocation creates a new instance of QualifierNamedQualifyInvocation
func NewQualifierNamedQualifyInvocation(a fmt.Scanner, b fmt.Scanner, c fmt.Scanner, d fmt.Scanner) *QualifierNamedQualifyInvocation {
	invocation := new(QualifierNamedQualifyInvocation)

	invocation.Parameters.A = a
	invocation.Parameters.B = b
	invocation.Parameters.C = c

	invocation.Results.D = d

	return invocation
}

// QualifierTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type QualifierTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeQualifier is a mock implementation of Qualifier for testing.
Use it in your tests as in this example:

	package example

	func TestWithQualifier(t *testing.T) {
		f := &main.FakeQualifier{
			QualifyHook: func(ident1 fmt.Scanner) (ident2 fmt.Scanner) {
				// ensure parameters meet expectations, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeQualify ...
		f.AssertQualifyCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeQualify.
*/
type FakeQualifier struct {
	QualifyHook      func(fmt.Scanner) fmt.Scanner
	NamedQualifyHook func(fmt.Scanner, fmt.Scanner, fmt.Scanner) fmt.Scanner

	QualifyCalls      []*QualifierQualifyInvocation
	NamedQualifyCalls []*QualifierNamedQualifyInvocation
}

// NewFakeQualifierDefaultPanic returns an instance of FakeQualifier with all hooks configured to panic
func NewFakeQualifierDefaultPanic() *FakeQualifier {
	return &FakeQualifier{
		QualifyHook: func(fmt.Scanner) (ident2 fmt.Scanner) {
			panic("Unexpected call to Qualifier.Qualify")
		},
		NamedQualifyHook: func(fmt.Scanner, fmt.Scanner, fmt.Scanner) (d fmt.Scanner) {
			panic("Unexpected call to Qualifier.NamedQualify")
		},
	}
}

// NewFakeQualifierDefaultFatal returns an instance of FakeQualifier with all hooks configured to call t.Fatal
func NewFakeQualifierDefaultFatal(t_sym1 QualifierTestingT) *FakeQualifier {
	return &FakeQualifier{
		QualifyHook: func(fmt.Scanner) (ident2 fmt.Scanner) {
			t_sym1.Fatal("Unexpected call to Qualifier.Qualify")
			return
		},
		NamedQualifyHook: func(fmt.Scanner, fmt.Scanner, fmt.Scanner) (d fmt.Scanner) {
			t_sym1.Fatal("Unexpected call to Qualifier.NamedQualify")
			return
		},
	}
}

// NewFakeQualifierDefaultError returns an instance of FakeQualifier with all hooks configured to call t.Error
func NewFakeQualifierDefaultError(t_sym2 QualifierTestingT) *FakeQualifier {
	return &FakeQualifier{
		QualifyHook: func(fmt.Scanner) (ident2 fmt.Scanner) {
			t_sym2.Error("Unexpected call to Qualifier.Qualify")
			return
		},
		NamedQualifyHook: func(fmt.Scanner, fmt.Scanner, fmt.Scanner) (d fmt.Scanner) {
			t_sym2.Error("Unexpected call to Qualifier.NamedQualify")
			return
		},
	}
}

func (f *FakeQualifier) Reset() {
	f.QualifyCalls = []*QualifierQualifyInvocation{}
	f.NamedQualifyCalls = []*QualifierNamedQualifyInvocation{}
}

func (f_sym3 *FakeQualifier) Qualify(ident1 fmt.Scanner) (ident2 fmt.Scanner) {
	if f_sym3.QualifyHook == nil {
		panic("Qualifier.Qualify() called but FakeQualifier.QualifyHook is nil")
	}

	invocation_sym3 := new(QualifierQualifyInvocation)
	f_sym3.QualifyCalls = append(f_sym3.QualifyCalls, invocation_sym3)

	invocation_sym3.Parameters.Ident1 = ident1

	ident2 = f_sym3.QualifyHook(ident1)

	invocation_sym3.Results.Ident2 = ident2

	return
}

// SetQualifyStub configures Qualifier.Qualify to always return the given values
func (f_sym4 *FakeQualifier) SetQualifyStub(ident2 fmt.Scanner) {
	f_sym4.QualifyHook = func(fmt.Scanner) fmt.Scanner {
		return ident2
	}
}

// SetQualifyInvocation configures Qualifier.Qualify to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeQualifier) SetQualifyInvocation(calls_sym5 []*QualifierQualifyInvocation, fallback_sym5 func() fmt.Scanner) {
	f_sym5.QualifyHook = func(ident1 fmt.Scanner) (ident2 fmt.Scanner) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.Ident1, ident1) {
				ident2 = call_sym5.Results.Ident2

				return
			}
		}

		return fallback_sym5()
	}
}

// QualifyCalled returns true if FakeQualifier.Qualify was called
func (f *FakeQualifier) QualifyCalled() bool {
	return len(f.QualifyCalls) != 0
}

// AssertQualifyCalled calls t.Error if FakeQualifier.Qualify was not called
func (f *FakeQualifier) AssertQualifyCalled(t QualifierTestingT) {
	t.Helper()
	if len(f.QualifyCalls) == 0 {
		t.Error("FakeQualifier.Qualify not called, expected at least one")
	}
}

// QualifyNotCalled returns true if FakeQualifier.Qualify was not called
func (f *FakeQualifier) QualifyNotCalled() bool {
	return len(f.QualifyCalls) == 0
}

// AssertQualifyNotCalled calls t.Error if FakeQualifier.Qualify was called
func (f *FakeQualifier) AssertQualifyNotCalled(t QualifierTestingT) {
	t.Helper()
	if len(f.QualifyCalls) != 0 {
		t.Error("FakeQualifier.Qualify called, expected none")
	}
}

// QualifyCalledOnce returns true if FakeQualifier.Qualify was called exactly once
func (f *FakeQualifier) QualifyCalledOnce() bool {
	return len(f.QualifyCalls) == 1
}

// AssertQualifyCalledOnce calls t.Error if FakeQualifier.Qualify was not called exactly once
func (f *FakeQualifier) AssertQualifyCalledOnce(t QualifierTestingT) {
	t.Helper()
	if len(f.QualifyCalls) != 1 {
		t.Errorf("FakeQualifier.Qualify called %d times, expected 1", len(f.QualifyCalls))
	}
}

// QualifyCalledN returns true if FakeQualifier.Qualify was called at least n times
func (f *FakeQualifier) QualifyCalledN(n int) bool {
	return len(f.QualifyCalls) >= n
}

// AssertQualifyCalledN calls t.Error if FakeQualifier.Qualify was called less than n times
func (f *FakeQualifier) AssertQualifyCalledN(t QualifierTestingT, n int) {
	t.Helper()
	if len(f.QualifyCalls) < n {
		t.Errorf("FakeQualifier.Qualify called %d times, expected >= %d", len(f.QualifyCalls), n)
	}
}

// QualifyCalledWith returns true if FakeQualifier.Qualify was called with the given values
func (f_sym6 *FakeQualifier) QualifyCalledWith(ident1 fmt.Scanner) bool {
	for _, call_sym6 := range f_sym6.QualifyCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertQualifyCalledWith calls t.Error if FakeQualifier.Qualify was not called with the given values
func (f_sym7 *FakeQualifier) AssertQualifyCalledWith(t QualifierTestingT, ident1 fmt.Scanner) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.QualifyCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Ident1, ident1) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeQualifier.Qualify not called with expected parameters")
	}
}

// QualifyCalledOnceWith returns true if FakeQualifier.Qualify was called exactly once with the given values
func (f_sym8 *FakeQualifier) QualifyCalledOnceWith(ident1 fmt.Scanner) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.QualifyCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Ident1, ident1) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertQualifyCalledOnceWith calls t.Error if FakeQualifier.Qualify was not called exactly once with the given values
func (f_sym9 *FakeQualifier) AssertQualifyCalledOnceWith(t QualifierTestingT, ident1 fmt.Scanner) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.QualifyCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Ident1, ident1) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeQualifier.Qualify called %d times with expected parameters, expected one", count_sym9)
	}
}

// QualifyResultsForCall returns the result values for the first call to FakeQualifier.Qualify with the given values
func (f_sym10 *FakeQualifier) QualifyResultsForCall(ident1 fmt.Scanner) (ident2 fmt.Scanner, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.QualifyCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Ident1, ident1) {
			ident2 = call_sym10.Results.Ident2
			found_sym10 = true
			break
		}
	}

	return
}

func (f_sym11 *FakeQualifier) NamedQualify(a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) (d fmt.Scanner) {
	if f_sym11.NamedQualifyHook == nil {
		panic("Qualifier.NamedQualify() called but FakeQualifier.NamedQualifyHook is nil")
	}

	invocation_sym11 := new(QualifierNamedQualifyInvocation)
	f_sym11.NamedQualifyCalls = append(f_sym11.NamedQualifyCalls, invocation_sym11)

	invocation_sym11.Parameters.A = a
	invocation_sym11.Parameters.B = b
	invocation_sym11.Parameters.C = c

	d = f_sym11.NamedQualifyHook(a, b, c)

	invocation_sym11.Results.D = d

	return
}

// SetNamedQualifyStub configures Qualifier.NamedQualify to always return the given values
func (f_sym12 *FakeQualifier) SetNamedQualifyStub(d fmt.Scanner) {
	f_sym12.NamedQualifyHook = func(fmt.Scanner, fmt.Scanner, fmt.Scanner) fmt.Scanner {
		return d
	}
}

// SetNamedQualifyInvocation configures Qualifier.NamedQualify to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym13 *FakeQualifier) SetNamedQualifyInvocation(calls_sym13 []*QualifierNamedQualifyInvocation, fallback_sym13 func() fmt.Scanner) {
	f_sym13.NamedQualifyHook = func(a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) (d fmt.Scanner) {
		for _, call_sym13 := range calls_sym13 {
			if reflect.DeepEqual(call_sym13.Parameters.A, a) && reflect.DeepEqual(call_sym13.Parameters.B, b) && reflect.DeepEqual(call_sym13.Parameters.C, c) {
				d = call_sym13.Results.D

				return
			}
		}

		return fallback_sym13()
	}
}

// NamedQualifyCalled returns true if FakeQualifier.NamedQualify was called
func (f *FakeQualifier) NamedQualifyCalled() bool {
	return len(f.NamedQualifyCalls) != 0
}

// AssertNamedQualifyCalled calls t.Error if FakeQualifier.NamedQualify was not called
func (f *FakeQualifier) AssertNamedQualifyCalled(t QualifierTestingT) {
	t.Helper()
	if len(f.NamedQualifyCalls) == 0 {
		t.Error("FakeQualifier.NamedQualify not called, expected at least one")
	}
}

// NamedQualifyNotCalled returns true if FakeQualifier.NamedQualify was not called
func (f *FakeQualifier) NamedQualifyNotCalled() bool {
	return len(f.NamedQualifyCalls) == 0
}

// AssertNamedQualifyNotCalled calls t.Error if FakeQualifier.NamedQualify was called
func (f *FakeQualifier) AssertNamedQualifyNotCalled(t QualifierTestingT) {
	t.Helper()
	if len(f.NamedQualifyCalls) != 0 {
		t.Error("FakeQualifier.NamedQualify called, expected none")
	}
}

// NamedQualifyCalledOnce returns true if FakeQualifier.NamedQualify was called exactly once
func (f *FakeQualifier) NamedQualifyCalledOnce() bool {
	return len(f.NamedQualifyCalls) == 1
}

// AssertNamedQualifyCalledOnce calls t.Error if FakeQualifier.NamedQualify was not called exactly once
func (f *FakeQualifier) AssertNamedQualifyCalledOnce(t QualifierTestingT) {
	t.Helper()
	if len(f.NamedQualifyCalls) != 1 {
		t.Errorf("FakeQualifier.NamedQualify called %d times, expected 1", len(f.NamedQualifyCalls))
	}
}

// NamedQualifyCalledN returns true if FakeQualifier.NamedQualify was called at least n times
func (f *FakeQualifier) NamedQualifyCalledN(n int) bool {
	return len(f.NamedQualifyCalls) >= n
}

// AssertNamedQualifyCalledN calls t.Error if FakeQualifier.NamedQualify was called less than n times
func (f *FakeQualifier) AssertNamedQualifyCalledN(t QualifierTestingT, n int) {
	t.Helper()
	if len(f.NamedQualifyCalls) < n {
		t.Errorf("FakeQualifier.NamedQualify called %d times, expected >= %d", len(f.NamedQualifyCalls), n)
	}
}

// NamedQualifyCalledWith returns true if FakeQualifier.NamedQualify was called with the given values
func (f_sym14 *FakeQualifier) NamedQualifyCalledWith(a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) bool {
	for _, call_sym14 := range f_sym14.NamedQualifyCalls {
		if reflect.DeepEqual(call_sym14.Parameters.A, a) && reflect.DeepEqual(call_sym14.Parameters.B, b) && reflect.DeepEqual(call_sym14.Parameters.C, c) {
			return true
		}
	}

	return false
}

// AssertNamedQualifyCalledWith calls t.Error if FakeQualifier.NamedQualify was not called with the given values
func (f_sym15 *FakeQualifier) AssertNamedQualifyCalledWith(t QualifierTestingT, a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) {
	t.Helper()
	var found_sym15 bool
	for _, call_sym15 := range f_sym15.NamedQualifyCalls {
		if reflect.DeepEqual(call_sym15.Parameters.A, a) && reflect.DeepEqual(call_sym15.Parameters.B, b) && reflect.DeepEqual(call_sym15.Parameters.C, c) {
			found_sym15 = true
			break
		}
	}

	if !found_sym15 {
		t.Error("FakeQualifier.NamedQualify not called with expected parameters")
	}
}

// NamedQualifyCalledOnceWith returns true if FakeQualifier.NamedQualify was called exactly once with the given values
func (f_sym16 *FakeQualifier) NamedQualifyCalledOnceWith(a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) bool {
	var count_sym16 int
	for _, call_sym16 := range f_sym16.NamedQualifyCalls {
		if reflect.DeepEqual(call_sym16.Parameters.A, a) && reflect.DeepEqual(call_sym16.Parameters.B, b) && reflect.DeepEqual(call_sym16.Parameters.C, c) {
			count_sym16++
		}
	}

	return count_sym16 == 1
}

// AssertNamedQualifyCalledOnceWith calls t.Error if FakeQualifier.NamedQualify was not called exactly once with the given values
func (f_sym17 *FakeQualifier) AssertNamedQualifyCalledOnceWith(t QualifierTestingT, a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) {
	t.Helper()
	var count_sym17 int
	for _, call_sym17 := range f_sym17.NamedQualifyCalls {
		if reflect.DeepEqual(call_sym17.Parameters.A, a) && reflect.DeepEqual(call_sym17.Parameters.B, b) && reflect.DeepEqual(call_sym17.Parameters.C, c) {
			count_sym17++
		}
	}

	if count_sym17 != 1 {
		t.Errorf("FakeQualifier.NamedQualify called %d times with expected parameters, expected one", count_sym17)
	}
}

// NamedQualifyResultsForCall returns the result values for the first call to FakeQualifier.NamedQualify with the given values
func (f_sym18 *FakeQualifier) NamedQualifyResultsForCall(a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) (d fmt.Scanner, found_sym18 bool) {
	for _, call_sym18 := range f_sym18.NamedQualifyCalls {
		if reflect.DeepEqual(call_sym18.Parameters.A, a) && reflect.DeepEqual(call_sym18.Parameters.B, b) && reflect.DeepEqual(call_sym18.Parameters.C, c) {
			d = call_sym18.Results.D
			found_sym18 = true
			break
		}
	}

	return
}
