// generated by "charlatan -dir=testdata/namedvaluer -output=testdata/namedvaluer/namedvaluer.go Namedvaluer".  DO NOT EDIT.

package main

import "reflect"

// NamedvaluerManyNamedInvocation represents a single call of FakeNamedvaluer.ManyNamed
type NamedvaluerManyNamedInvocation struct {
	Parameters struct {
		A string
		B string
		F int
		G int
	}
	Results struct {
		Ret bool
	}
}

// NewNamedvaluerManyNamedInvocation creates a new instance of NamedvaluerManyNamedInvocation
func NewNamedvaluerManyNamedInvocation(a string, b string, f int, g int, ret bool) *NamedvaluerManyNamedInvocation {
	invocation := new(NamedvaluerManyNamedInvocation)

	invocation.Parameters.A = a
	invocation.Parameters.B = b
	invocation.Parameters.F = f
	invocation.Parameters.G = g

	invocation.Results.Ret = ret

	return invocation
}

// NamedvaluerNamedInvocation represents a single call of FakeNamedvaluer.Named
type NamedvaluerNamedInvocation struct {
	Parameters struct {
		A int
		B string
	}
	Results struct {
		Ret bool
	}
}

// NewNamedvaluerNamedInvocation creates a new instance of NamedvaluerNamedInvocation
func NewNamedvaluerNamedInvocation(a int, b string, ret bool) *NamedvaluerNamedInvocation {
	invocation := new(NamedvaluerNamedInvocation)

	invocation.Parameters.A = a
	invocation.Parameters.B = b

	invocation.Results.Ret = ret

	return invocation
}

// NamedvaluerTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type NamedvaluerTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeNamedvaluer is a mock implementation of Namedvaluer for testing.
Use it in your tests as in this example:

	package example

	func TestWithNamedvaluer(t *testing.T) {
		f := &main.FakeNamedvaluer{
			ManyNamedHook: func(a string, b string, f int, g int) (ret bool) {
				// ensure parameters meet expectations, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeManyNamed ...
		f.AssertManyNamedCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeManyNamed.
*/
type FakeNamedvaluer struct {
	ManyNamedHook func(string, string, int, int) bool
	NamedHook     func(int, string) bool

	ManyNamedCalls []*NamedvaluerManyNamedInvocation
	NamedCalls     []*NamedvaluerNamedInvocation
}

// NewFakeNamedvaluerDefaultPanic returns an instance of FakeNamedvaluer with all hooks configured to panic
func NewFakeNamedvaluerDefaultPanic() *FakeNamedvaluer {
	return &FakeNamedvaluer{
		ManyNamedHook: func(string, string, int, int) (ret bool) {
			panic("Unexpected call to Namedvaluer.ManyNamed")
		},
		NamedHook: func(int, string) (ret bool) {
			panic("Unexpected call to Namedvaluer.Named")
		},
	}
}

// NewFakeNamedvaluerDefaultFatal returns an instance of FakeNamedvaluer with all hooks configured to call t.Fatal
func NewFakeNamedvaluerDefaultFatal(t_sym1 NamedvaluerTestingT) *FakeNamedvaluer {
	return &FakeNamedvaluer{
		ManyNamedHook: func(string, string, int, int) (ret bool) {
			t_sym1.Fatal("Unexpected call to Namedvaluer.ManyNamed")
			return
		},
		NamedHook: func(int, string) (ret bool) {
			t_sym1.Fatal("Unexpected call to Namedvaluer.Named")
			return
		},
	}
}

// NewFakeNamedvaluerDefaultError returns an instance of FakeNamedvaluer with all hooks configured to call t.Error
func NewFakeNamedvaluerDefaultError(t_sym2 NamedvaluerTestingT) *FakeNamedvaluer {
	return &FakeNamedvaluer{
		ManyNamedHook: func(string, string, int, int) (ret bool) {
			t_sym2.Error("Unexpected call to Namedvaluer.ManyNamed")
			return
		},
		NamedHook: func(int, string) (ret bool) {
			t_sym2.Error("Unexpected call to Namedvaluer.Named")
			return
		},
	}
}

func (f *FakeNamedvaluer) Reset() {
	f.ManyNamedCalls = []*NamedvaluerManyNamedInvocation{}
	f.NamedCalls = []*NamedvaluerNamedInvocation{}
}

func (f_sym3 *FakeNamedvaluer) ManyNamed(a string, b string, f int, g int) (ret bool) {
	if f_sym3.ManyNamedHook == nil {
		panic("Namedvaluer.ManyNamed() called but FakeNamedvaluer.ManyNamedHook is nil")
	}

	invocation_sym3 := new(NamedvaluerManyNamedInvocation)
	f_sym3.ManyNamedCalls = append(f_sym3.ManyNamedCalls, invocation_sym3)

	invocation_sym3.Parameters.A = a
	invocation_sym3.Parameters.B = b
	invocation_sym3.Parameters.F = f
	invocation_sym3.Parameters.G = g

	ret = f_sym3.ManyNamedHook(a, b, f, g)

	invocation_sym3.Results.Ret = ret

	return
}

// SetManyNamedStub configures Namedvaluer.ManyNamed to always return the given values
func (f_sym4 *FakeNamedvaluer) SetManyNamedStub(ret bool) {
	f_sym4.ManyNamedHook = func(string, string, int, int) bool {
		return ret
	}
}

// SetManyNamedInvocation configures Namedvaluer.ManyNamed to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeNamedvaluer) SetManyNamedInvocation(calls_sym5 []*NamedvaluerManyNamedInvocation, fallback_sym5 func() bool) {
	f_sym5.ManyNamedHook = func(a string, b string, f int, g int) (ret bool) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.A, a) && reflect.DeepEqual(call_sym5.Parameters.B, b) && reflect.DeepEqual(call_sym5.Parameters.F, f) && reflect.DeepEqual(call_sym5.Parameters.G, g) {
				ret = call_sym5.Results.Ret

				return
			}
		}

		return fallback_sym5()
	}
}

// ManyNamedCalled returns true if FakeNamedvaluer.ManyNamed was called
func (f *FakeNamedvaluer) ManyNamedCalled() bool {
	return len(f.ManyNamedCalls) != 0
}

// AssertManyNamedCalled calls t.Error if FakeNamedvaluer.ManyNamed was not called
func (f *FakeNamedvaluer) AssertManyNamedCalled(t NamedvaluerTestingT) {
	t.Helper()
	if len(f.ManyNamedCalls) == 0 {
		t.Error("FakeNamedvaluer.ManyNamed not called, expected at least one")
	}
}

// ManyNamedNotCalled returns true if FakeNamedvaluer.ManyNamed was not called
func (f *FakeNamedvaluer) ManyNamedNotCalled() bool {
	return len(f.ManyNamedCalls) == 0
}

// AssertManyNamedNotCalled calls t.Error if FakeNamedvaluer.ManyNamed was called
func (f *FakeNamedvaluer) AssertManyNamedNotCalled(t NamedvaluerTestingT) {
	t.Helper()
	if len(f.ManyNamedCalls) != 0 {
		t.Error("FakeNamedvaluer.ManyNamed called, expected none")
	}
}

// ManyNamedCalledOnce returns true if FakeNamedvaluer.ManyNamed was called exactly once
func (f *FakeNamedvaluer) ManyNamedCalledOnce() bool {
	return len(f.ManyNamedCalls) == 1
}

// AssertManyNamedCalledOnce calls t.Error if FakeNamedvaluer.ManyNamed was not called exactly once
func (f *FakeNamedvaluer) AssertManyNamedCalledOnce(t NamedvaluerTestingT) {
	t.Helper()
	if len(f.ManyNamedCalls) != 1 {
		t.Errorf("FakeNamedvaluer.ManyNamed called %d times, expected 1", len(f.ManyNamedCalls))
	}
}

// ManyNamedCalledN returns true if FakeNamedvaluer.ManyNamed was called at least n times
func (f *FakeNamedvaluer) ManyNamedCalledN(n int) bool {
	return len(f.ManyNamedCalls) >= n
}

// AssertManyNamedCalledN calls t.Error if FakeNamedvaluer.ManyNamed was called less than n times
func (f *FakeNamedvaluer) AssertManyNamedCalledN(t NamedvaluerTestingT, n int) {
	t.Helper()
	if len(f.ManyNamedCalls) < n {
		t.Errorf("FakeNamedvaluer.ManyNamed called %d times, expected >= %d", len(f.ManyNamedCalls), n)
	}
}

// ManyNamedCalledWith returns true if FakeNamedvaluer.ManyNamed was called with the given values
func (f_sym6 *FakeNamedvaluer) ManyNamedCalledWith(a string, b string, f int, g int) bool {
	for _, call_sym6 := range f_sym6.ManyNamedCalls {
		if reflect.DeepEqual(call_sym6.Parameters.A, a) && reflect.DeepEqual(call_sym6.Parameters.B, b) && reflect.DeepEqual(call_sym6.Parameters.F, f) && reflect.DeepEqual(call_sym6.Parameters.G, g) {
			return true
		}
	}

	return false
}

// AssertManyNamedCalledWith calls t.Error if FakeNamedvaluer.ManyNamed was not called with the given values
func (f_sym7 *FakeNamedvaluer) AssertManyNamedCalledWith(t NamedvaluerTestingT, a string, b string, f int, g int) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.ManyNamedCalls {
		if reflect.DeepEqual(call_sym7.Parameters.A, a) && reflect.DeepEqual(call_sym7.Parameters.B, b) && reflect.DeepEqual(call_sym7.Parameters.F, f) && reflect.DeepEqual(call_sym7.Parameters.G, g) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeNamedvaluer.ManyNamed not called with expected parameters")
	}
}

// ManyNamedCalledOnceWith returns true if FakeNamedvaluer.ManyNamed was called exactly once with the given values
func (f_sym8 *FakeNamedvaluer) ManyNamedCalledOnceWith(a string, b string, f int, g int) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.ManyNamedCalls {
		if reflect.DeepEqual(call_sym8.Parameters.A, a) && reflect.DeepEqual(call_sym8.Parameters.B, b) && reflect.DeepEqual(call_sym8.Parameters.F, f) && reflect.DeepEqual(call_sym8.Parameters.G, g) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertManyNamedCalledOnceWith calls t.Error if FakeNamedvaluer.ManyNamed was not called exactly once with the given values
func (f_sym9 *FakeNamedvaluer) AssertManyNamedCalledOnceWith(t NamedvaluerTestingT, a string, b string, f int, g int) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.ManyNamedCalls {
		if reflect.DeepEqual(call_sym9.Parameters.A, a) && reflect.DeepEqual(call_sym9.Parameters.B, b) && reflect.DeepEqual(call_sym9.Parameters.F, f) && reflect.DeepEqual(call_sym9.Parameters.G, g) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeNamedvaluer.ManyNamed called %d times with expected parameters, expected one", count_sym9)
	}
}

// ManyNamedResultsForCall returns the result values for the first call to FakeNamedvaluer.ManyNamed with the given values
func (f_sym10 *FakeNamedvaluer) ManyNamedResultsForCall(a string, b string, f int, g int) (ret bool, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.ManyNamedCalls {
		if reflect.DeepEqual(call_sym10.Parameters.A, a) && reflect.DeepEqual(call_sym10.Parameters.B, b) && reflect.DeepEqual(call_sym10.Parameters.F, f) && reflect.DeepEqual(call_sym10.Parameters.G, g) {
			ret = call_sym10.Results.Ret
			found_sym10 = true
			break
		}
	}

	return
}

func (f_sym11 *FakeNamedvaluer) Named(a int, b string) (ret bool) {
	if f_sym11.NamedHook == nil {
		panic("Namedvaluer.Named() called but FakeNamedvaluer.NamedHook is nil")
	}

	invocation_sym11 := new(NamedvaluerNamedInvocation)
	f_sym11.NamedCalls = append(f_sym11.NamedCalls, invocation_sym11)

	invocation_sym11.Parameters.A = a
	invocation_sym11.Parameters.B = b

	ret = f_sym11.NamedHook(a, b)

	invocation_sym11.Results.Ret = ret

	return
}

// SetNamedStub configures Namedvaluer.Named to always return the given values
func (f_sym12 *FakeNamedvaluer) SetNamedStub(ret bool) {
	f_sym12.NamedHook = func(int, string) bool {
		return ret
	}
}

// SetNamedInvocation configures Namedvaluer.Named to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym13 *FakeNamedvaluer) SetNamedInvocation(calls_sym13 []*NamedvaluerNamedInvocation, fallback_sym13 func() bool) {
	f_sym13.NamedHook = func(a int, b string) (ret bool) {
		for _, call_sym13 := range calls_sym13 {
			if reflect.DeepEqual(call_sym13.Parameters.A, a) && reflect.DeepEqual(call_sym13.Parameters.B, b) {
				ret = call_sym13.Results.Ret

				return
			}
		}

		return fallback_sym13()
	}
}

// NamedCalled returns true if FakeNamedvaluer.Named was called
func (f *FakeNamedvaluer) NamedCalled() bool {
	return len(f.NamedCalls) != 0
}

// AssertNamedCalled calls t.Error if FakeNamedvaluer.Named was not called
func (f *FakeNamedvaluer) AssertNamedCalled(t NamedvaluerTestingT) {
	t.Helper()
	if len(f.NamedCalls) == 0 {
		t.Error("FakeNamedvaluer.Named not called, expected at least one")
	}
}

// NamedNotCalled returns true if FakeNamedvaluer.Named was not called
func (f *FakeNamedvaluer) NamedNotCalled() bool {
	return len(f.NamedCalls) == 0
}

// AssertNamedNotCalled calls t.Error if FakeNamedvaluer.Named was called
func (f *FakeNamedvaluer) AssertNamedNotCalled(t NamedvaluerTestingT) {
	t.Helper()
	if len(f.NamedCalls) != 0 {
		t.Error("FakeNamedvaluer.Named called, expected none")
	}
}

// NamedCalledOnce returns true if FakeNamedvaluer.Named was called exactly once
func (f *FakeNamedvaluer) NamedCalledOnce() bool {
	return len(f.NamedCalls) == 1
}

// AssertNamedCalledOnce calls t.Error if FakeNamedvaluer.Named was not called exactly once
func (f *FakeNamedvaluer) AssertNamedCalledOnce(t NamedvaluerTestingT) {
	t.Helper()
	if len(f.NamedCalls) != 1 {
		t.Errorf("FakeNamedvaluer.Named called %d times, expected 1", len(f.NamedCalls))
	}
}

// NamedCalledN returns true if FakeNamedvaluer.Named was called at least n times
func (f *FakeNamedvaluer) NamedCalledN(n int) bool {
	return len(f.NamedCalls) >= n
}

// AssertNamedCalledN calls t.Error if FakeNamedvaluer.Named was called less than n times
func (f *FakeNamedvaluer) AssertNamedCalledN(t NamedvaluerTestingT, n int) {
	t.Helper()
	if len(f.NamedCalls) < n {
		t.Errorf("FakeNamedvaluer.Named called %d times, expected >= %d", len(f.NamedCalls), n)
	}
}

// NamedCalledWith returns true if FakeNamedvaluer.Named was called with the given values
func (f_sym14 *FakeNamedvaluer) NamedCalledWith(a int, b string) bool {
	for _, call_sym14 := range f_sym14.NamedCalls {
		if reflect.DeepEqual(call_sym14.Parameters.A, a) && reflect.DeepEqual(call_sym14.Parameters.B, b) {
			return true
		}
	}

	return false
}

// AssertNamedCalledWith calls t.Error if FakeNamedvaluer.Named was not called with the given values
func (f_sym15 *FakeNamedvaluer) AssertNamedCalledWith(t NamedvaluerTestingT, a int, b string) {
	t.Helper()
	var found_sym15 bool
	for _, call_sym15 := range f_sym15.NamedCalls {
		if reflect.DeepEqual(call_sym15.Parameters.A, a) && reflect.DeepEqual(call_sym15.Parameters.B, b) {
			found_sym15 = true
			break
		}
	}

	if !found_sym15 {
		t.Error("FakeNamedvaluer.Named not called with expected parameters")
	}
}

// NamedCalledOnceWith returns true if FakeNamedvaluer.Named was called exactly once with the given values
func (f_sym16 *FakeNamedvaluer) NamedCalledOnceWith(a int, b string) bool {
	var count_sym16 int
	for _, call_sym16 := range f_sym16.NamedCalls {
		if reflect.DeepEqual(call_sym16.Parameters.A, a) && reflect.DeepEqual(call_sym16.Parameters.B, b) {
			count_sym16++
		}
	}

	return count_sym16 == 1
}

// AssertNamedCalledOnceWith calls t.Error if FakeNamedvaluer.Named was not called exactly once with the given values
func (f_sym17 *FakeNamedvaluer) AssertNamedCalledOnceWith(t NamedvaluerTestingT, a int, b string) {
	t.Helper()
	var count_sym17 int
	for _, call_sym17 := range f_sym17.NamedCalls {
		if reflect.DeepEqual(call_sym17.Parameters.A, a) && reflect.DeepEqual(call_sym17.Parameters.B, b) {
			count_sym17++
		}
	}

	if count_sym17 != 1 {
		t.Errorf("FakeNamedvaluer.Named called %d times with expected parameters, expected one", count_sym17)
	}
}

// NamedResultsForCall returns the result values for the first call to FakeNamedvaluer.Named with the given values
func (f_sym18 *FakeNamedvaluer) NamedResultsForCall(a int, b string) (ret bool, found_sym18 bool) {
	for _, call_sym18 := range f_sym18.NamedCalls {
		if reflect.DeepEqual(call_sym18.Parameters.A, a) && reflect.DeepEqual(call_sym18.Parameters.B, b) {
			ret = call_sym18.Results.Ret
			found_sym18 = true
			break
		}
	}

	return
}
