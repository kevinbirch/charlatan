// generated by "charlatan -dir=testdata/array -output=testdata/array/array.go Array".  DO NOT EDIT.

package main

import "reflect"

// ArrayArrayParameterInvocation represents a single call of FakeArray.ArrayParameter
type ArrayArrayParameterInvocation struct {
	Parameters struct {
		Ident1 [3]string
	}
}

// ArrayArrayReturnInvocation represents a single call of FakeArray.ArrayReturn
type ArrayArrayReturnInvocation struct {
	Results struct {
		Ident1 [3]string
	}
}

// ArraySliceParameterInvocation represents a single call of FakeArray.SliceParameter
type ArraySliceParameterInvocation struct {
	Parameters struct {
		Ident1 []string
	}
}

// ArraySliceReturnInvocation represents a single call of FakeArray.SliceReturn
type ArraySliceReturnInvocation struct {
	Results struct {
		Ident1 []string
	}
}

// ArrayTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ArrayTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeArray is a mock implementation of Array for testing.
Use it in your tests as in this example:

	package example

	func TestWithArray(t *testing.T) {
		f := &main.FakeArray{
			ArrayParameterHook: func(ident1 [3]string) () {
				// ensure parameters meet expectations, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeArrayParameter ...
		f.AssertArrayParameterCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeArrayParameter.
*/
type FakeArray struct {
	ArrayParameterHook func([3]string)
	ArrayReturnHook    func() [3]string
	SliceParameterHook func([]string)
	SliceReturnHook    func() []string

	ArrayParameterCalls []*ArrayArrayParameterInvocation
	ArrayReturnCalls    []*ArrayArrayReturnInvocation
	SliceParameterCalls []*ArraySliceParameterInvocation
	SliceReturnCalls    []*ArraySliceReturnInvocation
}

// NewFakeArrayDefaultPanic returns an instance of FakeArray with all hooks configured to panic
func NewFakeArrayDefaultPanic() *FakeArray {
	return &FakeArray{
		ArrayParameterHook: func([3]string) {
			panic("Unexpected call to Array.ArrayParameter")
		},
		ArrayReturnHook: func() (ident1 [3]string) {
			panic("Unexpected call to Array.ArrayReturn")
		},
		SliceParameterHook: func([]string) {
			panic("Unexpected call to Array.SliceParameter")
		},
		SliceReturnHook: func() (ident1 []string) {
			panic("Unexpected call to Array.SliceReturn")
		},
	}
}

// NewFakeArrayDefaultFatal returns an instance of FakeArray with all hooks configured to call t.Fatal
func NewFakeArrayDefaultFatal(t ArrayTestingT) *FakeArray {
	return &FakeArray{
		ArrayParameterHook: func([3]string) {
			t.Fatal("Unexpected call to Array.ArrayParameter")
			return
		},
		ArrayReturnHook: func() (ident1 [3]string) {
			t.Fatal("Unexpected call to Array.ArrayReturn")
			return
		},
		SliceParameterHook: func([]string) {
			t.Fatal("Unexpected call to Array.SliceParameter")
			return
		},
		SliceReturnHook: func() (ident1 []string) {
			t.Fatal("Unexpected call to Array.SliceReturn")
			return
		},
	}
}

// NewFakeArrayDefaultError returns an instance of FakeArray with all hooks configured to call t.Error
func NewFakeArrayDefaultError(t ArrayTestingT) *FakeArray {
	return &FakeArray{
		ArrayParameterHook: func([3]string) {
			t.Error("Unexpected call to Array.ArrayParameter")
			return
		},
		ArrayReturnHook: func() (ident1 [3]string) {
			t.Error("Unexpected call to Array.ArrayReturn")
			return
		},
		SliceParameterHook: func([]string) {
			t.Error("Unexpected call to Array.SliceParameter")
			return
		},
		SliceReturnHook: func() (ident1 []string) {
			t.Error("Unexpected call to Array.SliceReturn")
			return
		},
	}
}

func (f *FakeArray) Reset() {
	f.ArrayParameterCalls = []*ArrayArrayParameterInvocation{}
	f.ArrayReturnCalls = []*ArrayArrayReturnInvocation{}
	f.SliceParameterCalls = []*ArraySliceParameterInvocation{}
	f.SliceReturnCalls = []*ArraySliceReturnInvocation{}
}

func (_f1 *FakeArray) ArrayParameter(ident1 [3]string) {
	if _f1.ArrayParameterHook == nil {
		panic("Array.ArrayParameter() called but FakeArray.ArrayParameterHook is nil")
	}

	invocation := new(ArrayArrayParameterInvocation)
	_f1.ArrayParameterCalls = append(_f1.ArrayParameterCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	_f1.ArrayParameterHook(ident1)

	return
}

// ArrayParameterCalled returns true if FakeArray.ArrayParameter was called
func (f *FakeArray) ArrayParameterCalled() bool {
	return len(f.ArrayParameterCalls) != 0
}

// AssertArrayParameterCalled calls t.Error if FakeArray.ArrayParameter was not called
func (f *FakeArray) AssertArrayParameterCalled(t ArrayTestingT) {
	t.Helper()
	if len(f.ArrayParameterCalls) == 0 {
		t.Error("FakeArray.ArrayParameter not called, expected at least one")
	}
}

// ArrayParameterNotCalled returns true if FakeArray.ArrayParameter was not called
func (f *FakeArray) ArrayParameterNotCalled() bool {
	return len(f.ArrayParameterCalls) == 0
}

// AssertArrayParameterNotCalled calls t.Error if FakeArray.ArrayParameter was called
func (f *FakeArray) AssertArrayParameterNotCalled(t ArrayTestingT) {
	t.Helper()
	if len(f.ArrayParameterCalls) != 0 {
		t.Error("FakeArray.ArrayParameter called, expected none")
	}
}

// ArrayParameterCalledOnce returns true if FakeArray.ArrayParameter was called exactly once
func (f *FakeArray) ArrayParameterCalledOnce() bool {
	return len(f.ArrayParameterCalls) == 1
}

// AssertArrayParameterCalledOnce calls t.Error if FakeArray.ArrayParameter was not called exactly once
func (f *FakeArray) AssertArrayParameterCalledOnce(t ArrayTestingT) {
	t.Helper()
	if len(f.ArrayParameterCalls) != 1 {
		t.Errorf("FakeArray.ArrayParameter called %d times, expected 1", len(f.ArrayParameterCalls))
	}
}

// ArrayParameterCalledN returns true if FakeArray.ArrayParameter was called at least n times
func (f *FakeArray) ArrayParameterCalledN(n int) bool {
	return len(f.ArrayParameterCalls) >= n
}

// AssertArrayParameterCalledN calls t.Error if FakeArray.ArrayParameter was called less than n times
func (f *FakeArray) AssertArrayParameterCalledN(t ArrayTestingT, n int) {
	t.Helper()
	if len(f.ArrayParameterCalls) < n {
		t.Errorf("FakeArray.ArrayParameter called %d times, expected >= %d", len(f.ArrayParameterCalls), n)
	}
}

// ArrayParameterCalledWith returns true if FakeArray.ArrayParameter was called with the given values
func (_f2 *FakeArray) ArrayParameterCalledWith(ident1 [3]string) (found bool) {
	for _, call := range _f2.ArrayParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertArrayParameterCalledWith calls t.Error if FakeArray.ArrayParameter was not called with the given values
func (_f3 *FakeArray) AssertArrayParameterCalledWith(t ArrayTestingT, ident1 [3]string) {
	t.Helper()
	var found bool
	for _, call := range _f3.ArrayParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeArray.ArrayParameter not called with expected parameters")
	}
}

// ArrayParameterCalledOnceWith returns true if FakeArray.ArrayParameter was called exactly once with the given values
func (_f4 *FakeArray) ArrayParameterCalledOnceWith(ident1 [3]string) bool {
	var count int
	for _, call := range _f4.ArrayParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertArrayParameterCalledOnceWith calls t.Error if FakeArray.ArrayParameter was not called exactly once with the given values
func (_f5 *FakeArray) AssertArrayParameterCalledOnceWith(t ArrayTestingT, ident1 [3]string) {
	t.Helper()
	var count int
	for _, call := range _f5.ArrayParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeArray.ArrayParameter called %d times with expected parameters, expected one", count)
	}
}

func (_f6 *FakeArray) ArrayReturn() (ident1 [3]string) {
	if _f6.ArrayReturnHook == nil {
		panic("Array.ArrayReturn() called but FakeArray.ArrayReturnHook is nil")
	}

	invocation := new(ArrayArrayReturnInvocation)
	_f6.ArrayReturnCalls = append(_f6.ArrayReturnCalls, invocation)

	ident1 = _f6.ArrayReturnHook()

	invocation.Results.Ident1 = ident1

	return
}

// ArrayReturnCalled returns true if FakeArray.ArrayReturn was called
func (f *FakeArray) ArrayReturnCalled() bool {
	return len(f.ArrayReturnCalls) != 0
}

// AssertArrayReturnCalled calls t.Error if FakeArray.ArrayReturn was not called
func (f *FakeArray) AssertArrayReturnCalled(t ArrayTestingT) {
	t.Helper()
	if len(f.ArrayReturnCalls) == 0 {
		t.Error("FakeArray.ArrayReturn not called, expected at least one")
	}
}

// ArrayReturnNotCalled returns true if FakeArray.ArrayReturn was not called
func (f *FakeArray) ArrayReturnNotCalled() bool {
	return len(f.ArrayReturnCalls) == 0
}

// AssertArrayReturnNotCalled calls t.Error if FakeArray.ArrayReturn was called
func (f *FakeArray) AssertArrayReturnNotCalled(t ArrayTestingT) {
	t.Helper()
	if len(f.ArrayReturnCalls) != 0 {
		t.Error("FakeArray.ArrayReturn called, expected none")
	}
}

// ArrayReturnCalledOnce returns true if FakeArray.ArrayReturn was called exactly once
func (f *FakeArray) ArrayReturnCalledOnce() bool {
	return len(f.ArrayReturnCalls) == 1
}

// AssertArrayReturnCalledOnce calls t.Error if FakeArray.ArrayReturn was not called exactly once
func (f *FakeArray) AssertArrayReturnCalledOnce(t ArrayTestingT) {
	t.Helper()
	if len(f.ArrayReturnCalls) != 1 {
		t.Errorf("FakeArray.ArrayReturn called %d times, expected 1", len(f.ArrayReturnCalls))
	}
}

// ArrayReturnCalledN returns true if FakeArray.ArrayReturn was called at least n times
func (f *FakeArray) ArrayReturnCalledN(n int) bool {
	return len(f.ArrayReturnCalls) >= n
}

// AssertArrayReturnCalledN calls t.Error if FakeArray.ArrayReturn was called less than n times
func (f *FakeArray) AssertArrayReturnCalledN(t ArrayTestingT, n int) {
	t.Helper()
	if len(f.ArrayReturnCalls) < n {
		t.Errorf("FakeArray.ArrayReturn called %d times, expected >= %d", len(f.ArrayReturnCalls), n)
	}
}

func (_f7 *FakeArray) SliceParameter(ident1 []string) {
	if _f7.SliceParameterHook == nil {
		panic("Array.SliceParameter() called but FakeArray.SliceParameterHook is nil")
	}

	invocation := new(ArraySliceParameterInvocation)
	_f7.SliceParameterCalls = append(_f7.SliceParameterCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	_f7.SliceParameterHook(ident1)

	return
}

// SliceParameterCalled returns true if FakeArray.SliceParameter was called
func (f *FakeArray) SliceParameterCalled() bool {
	return len(f.SliceParameterCalls) != 0
}

// AssertSliceParameterCalled calls t.Error if FakeArray.SliceParameter was not called
func (f *FakeArray) AssertSliceParameterCalled(t ArrayTestingT) {
	t.Helper()
	if len(f.SliceParameterCalls) == 0 {
		t.Error("FakeArray.SliceParameter not called, expected at least one")
	}
}

// SliceParameterNotCalled returns true if FakeArray.SliceParameter was not called
func (f *FakeArray) SliceParameterNotCalled() bool {
	return len(f.SliceParameterCalls) == 0
}

// AssertSliceParameterNotCalled calls t.Error if FakeArray.SliceParameter was called
func (f *FakeArray) AssertSliceParameterNotCalled(t ArrayTestingT) {
	t.Helper()
	if len(f.SliceParameterCalls) != 0 {
		t.Error("FakeArray.SliceParameter called, expected none")
	}
}

// SliceParameterCalledOnce returns true if FakeArray.SliceParameter was called exactly once
func (f *FakeArray) SliceParameterCalledOnce() bool {
	return len(f.SliceParameterCalls) == 1
}

// AssertSliceParameterCalledOnce calls t.Error if FakeArray.SliceParameter was not called exactly once
func (f *FakeArray) AssertSliceParameterCalledOnce(t ArrayTestingT) {
	t.Helper()
	if len(f.SliceParameterCalls) != 1 {
		t.Errorf("FakeArray.SliceParameter called %d times, expected 1", len(f.SliceParameterCalls))
	}
}

// SliceParameterCalledN returns true if FakeArray.SliceParameter was called at least n times
func (f *FakeArray) SliceParameterCalledN(n int) bool {
	return len(f.SliceParameterCalls) >= n
}

// AssertSliceParameterCalledN calls t.Error if FakeArray.SliceParameter was called less than n times
func (f *FakeArray) AssertSliceParameterCalledN(t ArrayTestingT, n int) {
	t.Helper()
	if len(f.SliceParameterCalls) < n {
		t.Errorf("FakeArray.SliceParameter called %d times, expected >= %d", len(f.SliceParameterCalls), n)
	}
}

// SliceParameterCalledWith returns true if FakeArray.SliceParameter was called with the given values
func (_f8 *FakeArray) SliceParameterCalledWith(ident1 []string) (found bool) {
	for _, call := range _f8.SliceParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertSliceParameterCalledWith calls t.Error if FakeArray.SliceParameter was not called with the given values
func (_f9 *FakeArray) AssertSliceParameterCalledWith(t ArrayTestingT, ident1 []string) {
	t.Helper()
	var found bool
	for _, call := range _f9.SliceParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeArray.SliceParameter not called with expected parameters")
	}
}

// SliceParameterCalledOnceWith returns true if FakeArray.SliceParameter was called exactly once with the given values
func (_f10 *FakeArray) SliceParameterCalledOnceWith(ident1 []string) bool {
	var count int
	for _, call := range _f10.SliceParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertSliceParameterCalledOnceWith calls t.Error if FakeArray.SliceParameter was not called exactly once with the given values
func (_f11 *FakeArray) AssertSliceParameterCalledOnceWith(t ArrayTestingT, ident1 []string) {
	t.Helper()
	var count int
	for _, call := range _f11.SliceParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeArray.SliceParameter called %d times with expected parameters, expected one", count)
	}
}

func (_f12 *FakeArray) SliceReturn() (ident1 []string) {
	if _f12.SliceReturnHook == nil {
		panic("Array.SliceReturn() called but FakeArray.SliceReturnHook is nil")
	}

	invocation := new(ArraySliceReturnInvocation)
	_f12.SliceReturnCalls = append(_f12.SliceReturnCalls, invocation)

	ident1 = _f12.SliceReturnHook()

	invocation.Results.Ident1 = ident1

	return
}

// SliceReturnCalled returns true if FakeArray.SliceReturn was called
func (f *FakeArray) SliceReturnCalled() bool {
	return len(f.SliceReturnCalls) != 0
}

// AssertSliceReturnCalled calls t.Error if FakeArray.SliceReturn was not called
func (f *FakeArray) AssertSliceReturnCalled(t ArrayTestingT) {
	t.Helper()
	if len(f.SliceReturnCalls) == 0 {
		t.Error("FakeArray.SliceReturn not called, expected at least one")
	}
}

// SliceReturnNotCalled returns true if FakeArray.SliceReturn was not called
func (f *FakeArray) SliceReturnNotCalled() bool {
	return len(f.SliceReturnCalls) == 0
}

// AssertSliceReturnNotCalled calls t.Error if FakeArray.SliceReturn was called
func (f *FakeArray) AssertSliceReturnNotCalled(t ArrayTestingT) {
	t.Helper()
	if len(f.SliceReturnCalls) != 0 {
		t.Error("FakeArray.SliceReturn called, expected none")
	}
}

// SliceReturnCalledOnce returns true if FakeArray.SliceReturn was called exactly once
func (f *FakeArray) SliceReturnCalledOnce() bool {
	return len(f.SliceReturnCalls) == 1
}

// AssertSliceReturnCalledOnce calls t.Error if FakeArray.SliceReturn was not called exactly once
func (f *FakeArray) AssertSliceReturnCalledOnce(t ArrayTestingT) {
	t.Helper()
	if len(f.SliceReturnCalls) != 1 {
		t.Errorf("FakeArray.SliceReturn called %d times, expected 1", len(f.SliceReturnCalls))
	}
}

// SliceReturnCalledN returns true if FakeArray.SliceReturn was called at least n times
func (f *FakeArray) SliceReturnCalledN(n int) bool {
	return len(f.SliceReturnCalls) >= n
}

// AssertSliceReturnCalledN calls t.Error if FakeArray.SliceReturn was called less than n times
func (f *FakeArray) AssertSliceReturnCalledN(t ArrayTestingT, n int) {
	t.Helper()
	if len(f.SliceReturnCalls) < n {
		t.Errorf("FakeArray.SliceReturn called %d times, expected >= %d", len(f.SliceReturnCalls), n)
	}
}
